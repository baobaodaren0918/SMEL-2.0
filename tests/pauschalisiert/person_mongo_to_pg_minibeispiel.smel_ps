-- SMEL Mini-Example: MongoDB -> PostgreSQL (Pauschalisiert Operations Version)
-- Person Document (multi-level nested objects + arrays) -> Normalized Tables
-- Direction: Denormalized (Embedded) -> Normalized (3NF)
--
-- Operation Semantics (per André Conrad reference):
--   FLATTEN: Flatten nested object fields into same table (reduce depth by 1)
--   UNNEST:  Extract nested object to separate table (normalization)
--   SPLIT:   Vertical partitioning of same-level fields
--   UNWIND:  Expand array into multiple rows in same table

MIGRATION person_mongo_to_pg:1.0
FROM DOCUMENT TO RELATIONAL
USING person_schema:1

-- ============================================
-- Source: MongoDB Person Document
-- ============================================
-- {
--   _id: "p001",
--   name: { vorname: "Lu", nachname: "Li" },
--   age: "28",
--   address: { street: "Hauptstrasse 10", city: "Berlin" },
--   employment: {
--     position: "Software Engineer",
--     company: {
--       name: "Tech Corp",
--       address: { street: "Business Str 5", city: "Munich" }
--     }
--   },
--   tags: ["student", "developer"],
--   knows: ["p002", "p003"]
-- }

-- ============================================
-- Target: PostgreSQL 3NF Tables (7 tables, 3-level nesting)
-- ============================================
-- person (person_id, vorname, nachname, age)
-- address (address_id, person_id, street, city)           ← Level 1
-- employment (employment_id, person_id, position)         ← Level 1
-- company (company_id, employment_id, name)               ← Level 2
-- company_address (company_address_id, company_id, street, city)  ← Level 3
-- person_tag (person_tag_id, person_id, tag_value)
-- person_knows (person_id, knows_person_id)

-- ============================================
-- Step 0: Rename primary key
-- ============================================
RENAME_PS FEATURE _id TO person_id IN person
-- Result:
-- person: { person_id, name{vorname,nachname}, age, address{street,city},
--           employment{position,company{name,address{street,city}}}, tags[], knows[] }

-- ============================================
-- Step 1: Extract address table (level 1)
-- ============================================
UNNEST_PS person.address:street,city AS address WITH person.person_id
ADD_PS KEY address.address_id AS String
ADD_PS REFERENCE address.person_id REFERENCES person(person_id) WITH CARDINALITY ONE_TO_ONE
-- Result:
-- person: { person_id, name{vorname,nachname}, age,
--           employment{position,company{name,address{street,city}}}, tags[], knows[] }
-- address: { address_id, person_id, street, city }

-- ============================================
-- Step 2: Extract employment table (level 1)
-- ============================================
UNNEST_PS person.employment:position AS employment WITH person.person_id
ADD_PS KEY employment.employment_id AS String
ADD_PS REFERENCE employment.person_id REFERENCES person(person_id) WITH CARDINALITY ONE_TO_ONE
-- Result:
-- person: { person_id, name{vorname,nachname}, age, tags[], knows[] }
-- address: { address_id, person_id, street, city }
-- employment: { employment_id, person_id, position, company{name,address{street,city}} }
--             ↑ company preserved as inner nested object!

-- ============================================
-- Step 3: Extract company table (level 2) - from employment table
-- ============================================
UNNEST_PS employment.company:name AS company WITH employment.employment_id
ADD_PS KEY company.company_id AS String
ADD_PS REFERENCE company.employment_id REFERENCES employment(employment_id) WITH CARDINALITY ONE_TO_ONE
-- Result:
-- person: { person_id, name{vorname,nachname}, age, tags[], knows[] }
-- address: { address_id, person_id, street, city }
-- employment: { employment_id, person_id, position }
-- company: { company_id, employment_id, name, address{street,city} }
--           ↑ address preserved as inner nested object!

-- ============================================
-- Step 4: Extract company_address table (level 3) - 3rd level nesting!
-- ============================================
UNNEST_PS company.address:street,city AS company_address WITH company.company_id
ADD_PS KEY company_address.company_address_id AS String
ADD_PS REFERENCE company_address.company_id REFERENCES company(company_id) WITH CARDINALITY ONE_TO_ONE
-- Result:
-- person: { person_id, name{vorname,nachname}, age, tags[], knows[] }
-- address: { address_id, person_id, street, city }
-- employment: { employment_id, person_id, position }
-- company: { company_id, employment_id, name }
-- company_address: { company_address_id, company_id, street, city }  ← Level 3!

-- ============================================
-- Step 5: Extract person_tag table (array 1:N)
-- ============================================
SPLIT_PS person INTO person(person_id, name, age, knows), person_tag(person_id, tags)
UNWIND_PS person_tag.tags
RENAME_PS FEATURE tags TO tag_value IN person_tag
ADD_PS KEY person_tag.person_tag_id AS String
ADD_PS REFERENCE person_tag.person_id REFERENCES person(person_id) WITH CARDINALITY ONE_TO_MANY
-- Result:
-- person: { person_id, name{vorname,nachname}, age, knows[] }
-- address, employment, company, company_address: (unchanged)
-- person_tag: { person_tag_id, person_id, tag_value }

-- ============================================
-- Step 6: Extract person_knows table (array M:N)
-- ============================================
SPLIT_PS person INTO person(person_id, name, age), person_knows(person_id, knows)
UNWIND_PS person_knows.knows
RENAME_PS FEATURE knows TO knows_person_id IN person_knows
ADD_PS REFERENCE person_knows.person_id REFERENCES person(person_id) WITH CARDINALITY ONE_TO_MANY
ADD_PS REFERENCE person_knows.knows_person_id REFERENCES person(person_id) WITH CARDINALITY ONE_TO_MANY
ADD_PS KEY (person_id, knows_person_id) TO person_knows
-- Result:
-- person: { person_id, name{vorname,nachname}, age }
-- person_knows: { person_id, knows_person_id }

-- ============================================
-- Step 7: Finalize person table
-- ============================================
FLATTEN_PS person.name
RENAME_PS FEATURE name_vorname TO vorname IN person
RENAME_PS FEATURE name_nachname TO nachname IN person
CAST_PS person.age TO Integer
-- Final Result (7 tables):
-- person: { person_id, vorname, nachname, age }
-- address: { address_id, person_id, street, city }
-- employment: { employment_id, person_id, position }
-- company: { company_id, employment_id, name }
-- company_address: { company_address_id, company_id, street, city }
-- person_tag: { person_tag_id, person_id, tag_value }
-- person_knows: { person_id, knows_person_id }
